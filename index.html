
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Use roblox database as unlimited cloud Storage">
    <title>
        Roblox Datastore's - Cloud Storage
    </title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
   <style>
         @font-face {
      font-family: 'Roboto';
      src: url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');
    }

    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
    }

    .main-nav {
      background-color: #0074d9;
      padding: 20px;
      display: flex;
      align-items: center;
    }

    .main-nav .logo {
      margin-right: auto;
    }

    .main-nav .navl {
      list-style: none;
      display: flex;
      justify-content: space-between;
      padding: 0;
      margin: 0;
    }

    .main-nav li {
      margin: 0;
      display: inline;
    }

    .main-nav a {
      text-decoration: none;
      color: #000;
      padding: 10px 20px;
      border-radius: 5px;
      transition: background-color 0.2s ease;
       font-size: 18px;
    }

    .main-nav a:hover {
      color: #545454;
    }

    .profile {
      display: flex;
      align-items: center;
    }

    .profile img {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      margin-left: 10px;
      cursor: pointer;
    }

    .dropdown {
      position: absolute;
      top: 55px;
      right: 30px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      display: none;
    }

    .profile:hover .dropdown {
      display: block;
    }

    .dropdown-item {
      padding: 5px;
      cursor: pointer;
    }

    .dropdown-item:hover {
      background-color: #f1f1f1;
    }

.form-container {
  padding: 20px;
  max-width: 300px;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

h1 {
  font-size: 24px;
  margin-bottom: 20px;
}

form {
  display: flex;
  flex-direction: column;
}

label {
  margin-bottom: 5px;
}

input {
  width: 100%;
  padding: 10px;
  margin-bottom: 10px;
  border-radius: 5px;
  border: 1px solid #ddd;
  background-color: #fff;
  color: #333;
}

button {
  background-color: #6FBBFD;
  color: #000;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s;
}
button:hover {
  background-color: #5D9ED6;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.upload-button {
  padding: 10px 20px;
  color: #000000;
  border: none;
  border-radius: 4px;
  font-size: 17px;
  cursor: pointer;
}

.dashboard-container {
  display: flex;
  justify-content: space-between;
  max-width: 800px;
  margin: 0 auto;
}

.dash-cont {
  flex: 1;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}
.dash-cont + .dash-cont {
  margin-left: 20px; /* Adjust the spacing as needed */
}

.list-item {
  border: 1px solid #ccc;
  padding: 10px;
  margin: 5px;
  background-color: #f9f9f9;
  max-width: 100%;
  display: flex; /* Ensure that the contents don't overflow */
  align-items: center; /* Center vertically within the div */
  gap: 10px; /* Add some spacing between the icon and text */
}

.list-item span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


.list-item::after {
  content: "";
  flex: 1;
}



/* Apply basic styling */
a {
  color: #525252; /* Link color */
  text-decoration: none; /* Remove underline */
  transition: color 0.3s; /* Add a smooth transition for color change */
  text-decoration: none;
}

/* Style links on hover */
a:hover {
  color: #000000; /* Change color on hover */
  text-decoration: none;
  cursor: pointer;
}

/* Style links for visited pages */
a:visited {
  color: #525252; /* Visited link color */
  text-decoration: none;
}

a:active {
  background-color: transparent;
}

.material-icons {
  position: absolute;
  right: 20px;
}


   </style>
  
</head>



  <nav class="main-nav">
  <div class="logo">
    <a href="/">
      <img src="https://cdn.glitch.global/79010910-a390-4a9c-9660-592915560bec/6295417.png" alt="Logo" width="50" height="50">
    </a>
  </div>
  
    <div class="cli">
      <ul class="navl">
     
      </ul>
    </div>
    
    <div class="profile">
        <img src="https://cdn.glitch.global/79010910-a390-4a9c-9660-592915560bec/421-4212617_person-placeholder-image-transparent-hd-png-download.png?v=1692095398338" alt="Profile Picture">
        <div class="dropdown">
          <div class="dropdown-item">
            <a  onclick="logout()">Log out</a>
            <script>
                function logout() {
                    if (confirm("Are you sure you wanna reset your login")) {
                      localStorage.clear();
                      reload()
                    }
           
                }
            </script>
          </div>
          <br>
          <div class="dropdown-item">
            <a  onclick="getlogin()">Get Login</a>
            <script>
              function getlogin() {
                let f = 'Unlimited Cloud storage using roblox datastores\n\nCredentials:\n';
                f += `roblox api key: ${localStorage.getItem("apikey")}\n`;
                f += `universe ID: ${localStorage.getItem("id")}\n`;
                f += `glitch proxy: ${localStorage.getItem("gname")}\n`;
                f += `https://movlol.github.io/unlimitedcloud/`;
            
                const blob = new Blob([f], { type: 'text/plain' });
            
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'Roblox Datastores.txt';

                link.click();
              }
            </script>
            
          </div>

        </div>
      </div>


  </nav>

  <div id="auth" style="display: none;">
    <center>
        <h1>
          Set roblox API keys
        </h1>
  
        <div class="form-container">
            <input type="text" id="ai" placeholder="Enter roblox api key">
            <input type="text" id="ui" placeholder="Enter your universe ID">
            <input type="text" id="gn" placeholder="Enter your glitch proxy">
          <br>
          <button id="signup" onclick="handleSignup()">Set API keys</button>
      
          <p>Dont have roblox API keys?  Select universe datastore, choose a place, read,write and delete, ip: 0.0.0.0/0 <a href="https://create.roblox.com/dashboard/credentials?activeTab=ApiKeysTab">HERE</a></p>
          <p>If you lose your API key create a new one on the same roblox universe and all your files will be safe</p>

          <p>Dont have roblox Glitch Proxy? open <a href="https://glitch.com/edit/#!/remix/roblox-datastore-nocors">HERE</a>, copy the name of the glitch project</p>
          <p>Make a glitch account so that your project does not expire</p>

          <p>After setting ur credentials hover over the person icon in the top right and click get Login to get access back into your account from anywhere, you can save this in your google drive so u can access your files again</p>
        </div>
        
      <script>
        async function handleSignup() {
          const key = document.getElementById('ai').value;
          const user = document.getElementById('ui').value;
          const proxy = document.getElementById('gn').value;

          localStorage.setItem("apikey", key)
          localStorage.setItem("id", user)
          localStorage.setItem("gname", proxy)
          reload()
        }
      </script>
          
      </center>



  </div>


  <div id="content" style="display: none;">

<script>
  function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = (c === 'x') ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

  function removeQueryParameters() {
    var newUrl = window.location.origin + window.location.pathname;
    history.replaceState({}, document.title, newUrl);
}

removeQueryParameters();

  
var dValue = "root"
var dValueLook = "root"

var emoji = {
  "txt": "📄",
  "doc": "📃",
  "docx": "📑",
  "pdf": "📰",
  "ppt": "📊",
  "pptx": "📈",
  "xls": "📉",
  "xlsx": "📊",
  "csv": "📊",
  "jpg": "🖼️",
  "png": "🖼️",
  "webp": "🖼️",
  "gif": "🖼️",
  "mp3": "🎵",
  "wav": "🎵",
  "mp4": "🎥",
  "mov": "🎥",
  "avi": "🎥",
  "zip": "📦",
  "rar": "📦",
  "exe": "💻",
  "html": "🌐",
  "css": "🎨",
  "js": "📜",
  "json": "📄",
  "xml": "🧾",
  "cpp": "💻",
  "java": "☕",
  "py": "🐍",
  "rb": "💎",
  "php": "🐘",
  "md": "📝",
  "key": "🔑",
  "sql": "🗃️",
  "bak": "🗑️",
  "conf": "⚙️",
  "log": "📋",
  "cfg": "⚙️",
  "dll": "🔌",
  "jar": "🍶",
  "ttf": "🔤",
  "otf": "🔤",
  "psd": "🎨",
  "svg": "🎨",
  "tmp": "❄️",
  "iso": "💿",
  "backup": "🗄️",
  "bat": "🦇",
  "sh": "🐚",
  "h": "💻",
  "hpp": "💻",
  "class": "📦",
  "obj": "🧱",
  "swift": "🐦",
  "kt": "🐱",
  "cs": "💻",
  "vb": "💻",
  "rtf": "📄",
  "ps1": "📜",
  "patch": "🩹",
  "cxx": "💻",
  "hxx": "💻",
  "war": "⚔️",
  "ear": "👂",
  "pyc": "🐍",
  "pyo": "🐍",
  "whl": "🔧",
  "swp": "🔄",
  "csproj": "📦",
  "suo": "🔒",
  "pdb": "🔒",
  "dsp": "🔊",
  "vbp": "🔌",
  "vbw": "🔌",
  "mak": "🛠️",
  "ini": "⚙️",
  "asd": "🗑️",
  "torrent": "🌊",
  "vmx": "🖥️",
  "vmdk": "💽",
  "vagrant": "🧙",
  "img": "🖼️",
  "bin": "🗑️",
  "cue": "🎮",
  "ova": "🥚",
  "tar": "🗃️",
  "gz": "🗃️",
  "xz": "🗃️",
  "bz2": "🗃️",
  "apk": "📱",
};


</script>

<div id="upload-progress-popup" style="position: fixed; top: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px; border-radius: 5px; display: none;">
  
  <p id="upload-text">Connecting...</p>
  
  <div id="upload-progress-bar" style="width: 100%; height: 10px; background-color: white; margin-top: 5px; border-radius: 5px;">
    <div id="upload-progress" style="width: 0%; height: 100%; background-color: green; border-radius: 5px;"></div>
  </div>

  <p id="upload-text2"></p>
</div>


<script>
  var upload = false
  window.addEventListener("beforeunload", function(event) {
    if (upload) {
      event.returnValue = "You are still uploading";
    }
    
  });
</script>


<center>
<div class="files" id="uploads-container" style="width: 100%">
<br>
<br>

  <input type="file" id="file-input" multiple style="display: none;">
<button class="upload-button" onclick="uploadFile()">
        <img src="https://cdn.glitch.global/79010910-a390-4a9c-9660-592915560bec/2055824%20(2).png" alt="Upload Icon" style="width: 20px; height: 20px; margin-right: 10px;">
        Upload File's
      </button>

<button class="upload-button" onclick="createFolder()">
        <img src="https://cdn.glitch.global/6b03bc19-4efa-46fb-a88a-f2bf62a6b617/1514350.webp?v=1692184865" alt="Upload Icon" style="width: 20px; height: 20px; margin-right: 10px;">
        Create Folder
      </button>
  
  <br>
   <br>
  <div id="dir"></div>

  

  <script>

    function createpath() {

      var segments = dValueLook.split('/');
      var segments2 = dValue.split('/');

      var linksHTML = segments.map(function(segment, index) {
          var path = segments.slice(0, index + 1).join('/');
          return '<a class="breadcrumb-link">' + decodeURIComponent(segment) + '</a>';
      });
      
      var dirDiv = document.getElementById('dir');
      dirDiv.innerHTML = linksHTML.join(' / ');

      var breadcrumbLinks = document.querySelectorAll('.breadcrumb-link');
      breadcrumbLinks.forEach(function(link) {
        link.addEventListener('click', function() {
            var clickedSegment = this.textContent;
            var clickedIndex = Array.from(breadcrumbLinks).indexOf(this);

            dValue = segments2.slice(0, clickedIndex + 1).join('/');
            dValueLook = segments.slice(0, clickedIndex + 1).join('/');

            loaduploads();
            createpath();
        });
    });
      
    }


    
  const fileInput = document.getElementById('file-input');
      fileInput.addEventListener('change', handleFileSelection);

      function uploadFile() {
        fileInput.click();
      }

    async function createFolder() {
      const folderName = prompt("Folder Name:");
      
      if (folderName) {
       let uploadsObject = await getasync("u", encodeURIComponent(dValue))
        if (!uploadsObject) {
            uploadsObject = {}
        } else {
            uploadsObject = JSON.parse(uploadsObject)
        }

        uploadsObject[folderName] = [generateUUID(),"folder"]

        console.log(uploadsObject)

        await setasync("u", encodeURIComponent(dValue), JSON.stringify(uploadsObject))
        loaduploads()
        
      } else {
      }
    }


function generateFileKey() { //key no-one could guess
    var key = "";
    while (key.length < 100) {
        var part = (Math.random() * 46656) | 0;
        part = ("000" + part.toString(36)).slice(-3);
        key += part;
    }
    return key.slice(0, 100);
}



    
async function setfile(file, number, max) {
  return new Promise((resolve, reject) => {
    const uploadProgressBar = document.getElementById("upload-progress");
    const uploadProgressText = document.getElementById("upload-text");
    const upt2 = document.getElementById("upload-text2");

    const filename = file.name;

    if (upload) {
      alert("You are already uploading a file");
      reject(new Error("File upload already in progress"));
      return;
    }
    if (downloading) {
      alert("Can't upload while downloading");
      reject(new Error("Download in progress"));
      return;
    }

    upload = true;

    const chunksstorageid = generateUUID();
    const dvvv = encodeURIComponent(dValue);

    const chunkSize = 2 * 1024 * 1024;
    const totalChunks = Math.ceil(file.size / chunkSize);
    let currentChunk = 0;

    function readChunk(start) {
      const end = Math.min(start + chunkSize, file.size);
      const chunk = file.slice(start, end);

      const reader = new FileReader();

      reader.onload = async function () {
        const chunkData = reader.result;
        await sendChunk(chunkData, currentChunk);

        // Update progress bar and text
        currentChunk++;

        const progress = (currentChunk / totalChunks) * 100;
        uploadProgressBar.style.width = `${progress}%`;
        uploadProgressText.textContent = `Uploading ${filename}... ${progress.toFixed(2)}%`;

        const uploadedMB = (currentChunk * chunkSize) / (1024 * 1024);
        const totalMB = file.size / (1024 * 1024);
        upt2.textContent = `${uploadedMB.toFixed(2)} MB / ${totalMB.toFixed(2)} MB\n${number}/${max} Files`;

        document.title = `${progress.toFixed(2)}%`;

        // If there are more chunks, read the next chunk
        if (currentChunk < totalChunks) {
          readChunk(start + chunkSize);
        } else {
          uploadProgressText.textContent = `Connecting...`;
          upt2.textContent = ``;
          const uploadProgressPopup = document.getElementById("upload-progress-popup");
          uploadProgressPopup.style.display = "none";

          let uploadsObject = await getasync("u", dvvv);
          if (!uploadsObject) {
            uploadsObject = {};
          } else {
            uploadsObject = JSON.parse(uploadsObject);
          }

          uploadsObject[filename] = [generateUUID(), chunksstorageid, totalChunks, file.size];

          console.log(uploadsObject);

          await setasync("u", dvvv, JSON.stringify(uploadsObject));
          loaduploads();

          upload = false;
          document.title = `Roblox Datastore's - Cloud Storage`;

          // Resolve the promise here
          resolve();
        }
      };

      reader.onerror = function () {
        console.error("Error reading file chunk");
        reject(new Error("Error reading file chunk"));
      };

      // Read the chunk as an ArrayBuffer
      reader.readAsArrayBuffer(chunk);
    }

    readChunk(0);

    async function sendChunk(chunkData, chunkid) {
      await setasync(chunksstorageid, chunkid.toString(), chunkData);
    }
  });
}

    
      async function handleFileSelection(event) {
        const allfiles = event.target.files.length;

        let i = 0
        for (const file of (event.target.files)) {
          i += 1
          const uploadProgressPopup = document.getElementById("upload-progress-popup");
          uploadProgressPopup.style.display = "block";

          const uploadProgressBar = document.getElementById("upload-progress");
          const uploadProgressText = document.querySelector("#upload-progress-popup");
          const updateInterval = 100;
     
          await setfile(file, i, allfiles+1);

        };
        
      }
  
  </script>
  

  

  
  
  
</div>
  
</center>



  <script>
    function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

let downloading = false

async function downloadfile(filename, chunkid, totalchunks, filesize) {
  if (downloading) {
    alert("You are already downloading a file.")
    return
  }
  if (upload) {
    return alert("Cant download while uploading")
  }

  downloading = true

  const uploadProgressPopup = document.getElementById("upload-progress-popup");
  uploadProgressPopup.style.display = "block";

  const uploadProgressBar = document.getElementById("upload-progress");
  const uploadProgressText = document.getElementById("upload-text");
  const upt2 = document.getElementById("upload-text2");
    
    
  let allchunks = []

  for (let i = 0; i < totalchunks; i++) {

    const uploadedMB = (i * 2048) / (1024);
    
          const totalMB = filesize / (1024 * 1024);
          upt2.textContent = `${uploadedMB.toFixed(2)} MB / ${totalMB.toFixed(2)} MB`;

    const chunk = await getasync(chunkid, i.toString(), true)
    allchunks.push(chunk)

    const progress = (i / totalchunks) * 100;
          uploadProgressBar.style.width = `${progress}%`;
          uploadProgressText.textContent = `Downloading ${filename}... ${progress.toFixed(2)}%`;
          document.title = `${progress.toFixed(2)}%`




  }

  uploadProgressText.textContent = `Connecting...`;
  uploadProgressPopup.style.display = "none";
  const combinedBlob = new Blob(allchunks);

  const downloadLink = document.createElement("a");
  const url = URL.createObjectURL(combinedBlob);
  downloadLink.href = url;
  downloadLink.download = filename
  downloadLink.textContent = `Download ready!: ${filename}`
  downloadLink.click();
  downloading = false

  document.getElementById("uploads-container").appendChild(downloadLink)
  document.title = `Roblox Datastore's - Cloud Storage`
  
  
}


async function createitems(uploadsObject, dva) {
  if (dValue != dva) {
    return
  }
  
  const uploadsContainer = document.getElementById("uploads-container");

  const existingLinks = uploadsContainer.querySelectorAll(".itemlol");
  existingLinks.forEach(link => {
    if (link.parentNode === uploadsContainer) {
      uploadsContainer.removeChild(link);
    }
  });
  
  const uploadsEntries = Object.entries(uploadsObject)

  // Separate folders and files
  const folders = uploadsEntries.filter(([filename]) => uploadsObject[filename][1] === "folder");
  const files = uploadsEntries.filter(([filename]) => uploadsObject[filename][1] !== "folder");

  // Sort folders and files alphabetically
  folders.sort((a, b) => a[0].localeCompare(b[0]));
  files.sort((a, b) => a[0].localeCompare(b[0]));


  // Create and append folder entries (colored yellow)
  folders.forEach(([filename, filelink]) => {
    const link = document.createElement("a");
    link.classList.add("itemlol")

    link.addEventListener("click", function(event) {
        event.preventDefault();
        dValue = dValue + "/" + filelink[0]
        dValueLook = dValueLook + "/" + filename
      loaduploads()
    });

    const div = document.createElement("div");
    div.className = "list-item folder"; // Apply a CSS class for styling
    div.style.backgroundColor = "#5AB0FA"; // Set the background color

    const span = document.createElement("span");
    span.textContent = "📁" + filename;

    const delbutton = document.createElement("i")
    delbutton.textContent = "delete"
    delbutton.classList.add("material-icons")
    
    delbutton.addEventListener("click", async function(event) {
        event.stopPropagation();
        if (confirm(`Would you like to delete folder ${filename}`)) {

          let uploadsObject = await getasync("u", encodeURIComponent(dValue))
        if (!uploadsObject) {
            uploadsObject = {}
        } else {
            uploadsObject = JSON.parse(uploadsObject)
        }

        delete uploadsObject[filename]

        console.log(uploadsObject)

        await setasync("u", encodeURIComponent(dValue), JSON.stringify(uploadsObject))
        loaduploads()


        }
    });

    div.appendChild(span);
    div.appendChild(delbutton)
    link.appendChild(div);
    uploadsContainer.appendChild(link);



  });

  function getFileExtension(fileName) {
  var parts = fileName.split('.');
  if (parts.length > 1) {
    return parts.pop();
  }
  return ""; // If no extension found
}

  
  // Create and append file entries
  files.forEach(([filename, filelink]) => {
    const link = document.createElement("a");
    link.classList.add("itemlol")


var fileExtension = getFileExtension(filename);
    const div = document.createElement("div");
    div.className = "list-item";
    let e = emoji[fileExtension]
    if (!e) {
      e = "❓"
    }

    const span = document.createElement("span");
        span.textContent = e + filename;
 
      const delbutton = document.createElement("i")
      delbutton.textContent = "delete"
      delbutton.classList.add("material-icons")

      delbutton.addEventListener("click", async function(event) {
          event.stopPropagation();
          if (confirm(`Would you like to delete file ${filename}`)) {

            let uploadsObject = await getasync("u", encodeURIComponent(dValue))
          if (!uploadsObject) {
              uploadsObject = {}
          } else {
              uploadsObject = JSON.parse(uploadsObject)
          }

          delete uploadsObject[filename]

          console.log(uploadsObject)

          await setasync("u", encodeURIComponent(dValue), JSON.stringify(uploadsObject))
          loaduploads()


          }
      });


    div.appendChild(span);
    div.appendChild(delbutton)
    link.appendChild(div);
    uploadsContainer.appendChild(link);
  
    
    link.addEventListener("click", function(event) {
        event.preventDefault();
        downloadfile(filename, filelink[1], filelink[2], filelink[3])
    });

  });
}



async function loaduploads() {
   createpath()
  createitems({}, dValue)

  let i = localStorage.getItem("up1" + encodeURIComponent(dValue))


  if (i) {
    const cachedUploadsObject = JSON.parse(i);
    createitems(cachedUploadsObject, dValue)
  }

  let started = dValue
  
 // const response = await fetch("/uploads?d=" + encodeURIComponent(started));

  let uploadsObject = await getasync("u", encodeURIComponent(started))
  if (!uploadsObject) {
    uploadsObject = {}
  } else {
    uploadsObject = JSON.parse(uploadsObject)
    localStorage.setItem("up1" + encodeURIComponent(started), JSON.stringify(uploadsObject));
  }




  createitems(uploadsObject, started)


}


document.addEventListener("DOMContentLoaded", function() {
  loaduploads();
});

  </script>

    
  </div>

  <script>
    function reload() {
        document.getElementById("auth").style.display = "none"
        document.getElementById("content").style.display = "none"

        const apikey = localStorage.getItem("apikey")
        const userid = localStorage.getItem("id")
        if (!apikey || !userid) {
            document.getElementById("auth").style.display = ""
        } else {
            document.getElementById("content").style.display = ""
        }
    }
    reload()

  </script>

  <script>
    var MD5 = function(d){var r = M(V(Y(X(d),8*d.length)));return r.toLowerCase()};function M(d){for(var _,m="0123456789ABCDEF",f="",r=0;r<d.length;r++)_=d.charCodeAt(r),f+=m.charAt(_>>>4&15)+m.charAt(15&_);return f}function X(d){for(var _=Array(d.length>>2),m=0;m<_.length;m++)_[m]=0;for(m=0;m<8*d.length;m+=8)_[m>>5]|=(255&d.charCodeAt(m/8))<<m%32;return _}function V(d){for(var _="",m=0;m<32*d.length;m+=8)_+=String.fromCharCode(d[m>>5]>>>m%32&255);return _}function Y(d,_){d[_>>5]|=128<<_%32,d[14+(_+64>>>9<<4)]=_;for(var m=1732584193,f=-271733879,r=-1732584194,i=271733878,n=0;n<d.length;n+=16){var h=m,t=f,g=r,e=i;f=md5_ii(f=md5_ii(f=md5_ii(f=md5_ii(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_ff(f=md5_ff(f=md5_ff(f=md5_ff(f,r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+0],7,-680876936),f,r,d[n+1],12,-389564586),m,f,d[n+2],17,606105819),i,m,d[n+3],22,-1044525330),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+4],7,-176418897),f,r,d[n+5],12,1200080426),m,f,d[n+6],17,-1473231341),i,m,d[n+7],22,-45705983),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+8],7,1770035416),f,r,d[n+9],12,-1958414417),m,f,d[n+10],17,-42063),i,m,d[n+11],22,-1990404162),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+12],7,1804603682),f,r,d[n+13],12,-40341101),m,f,d[n+14],17,-1502002290),i,m,d[n+15],22,1236535329),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+1],5,-165796510),f,r,d[n+6],9,-1069501632),m,f,d[n+11],14,643717713),i,m,d[n+0],20,-373897302),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+5],5,-701558691),f,r,d[n+10],9,38016083),m,f,d[n+15],14,-660478335),i,m,d[n+4],20,-405537848),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+9],5,568446438),f,r,d[n+14],9,-1019803690),m,f,d[n+3],14,-187363961),i,m,d[n+8],20,1163531501),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+13],5,-1444681467),f,r,d[n+2],9,-51403784),m,f,d[n+7],14,1735328473),i,m,d[n+12],20,-1926607734),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+5],4,-378558),f,r,d[n+8],11,-2022574463),m,f,d[n+11],16,1839030562),i,m,d[n+14],23,-35309556),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+1],4,-1530992060),f,r,d[n+4],11,1272893353),m,f,d[n+7],16,-155497632),i,m,d[n+10],23,-1094730640),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+13],4,681279174),f,r,d[n+0],11,-358537222),m,f,d[n+3],16,-722521979),i,m,d[n+6],23,76029189),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+9],4,-640364487),f,r,d[n+12],11,-421815835),m,f,d[n+15],16,530742520),i,m,d[n+2],23,-995338651),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+0],6,-198630844),f,r,d[n+7],10,1126891415),m,f,d[n+14],15,-1416354905),i,m,d[n+5],21,-57434055),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+12],6,1700485571),f,r,d[n+3],10,-1894986606),m,f,d[n+10],15,-1051523),i,m,d[n+1],21,-2054922799),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+8],6,1873313359),f,r,d[n+15],10,-30611744),m,f,d[n+6],15,-1560198380),i,m,d[n+13],21,1309151649),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+4],6,-145523070),f,r,d[n+11],10,-1120210379),m,f,d[n+2],15,718787259),i,m,d[n+9],21,-343485551),m=safe_add(m,h),f=safe_add(f,t),r=safe_add(r,g),i=safe_add(i,e)}return Array(m,f,r,i)}function md5_cmn(d,_,m,f,r,i){return safe_add(bit_rol(safe_add(safe_add(_,d),safe_add(f,i)),r),m)}function md5_ff(d,_,m,f,r,i,n){return md5_cmn(_&m|~_&f,d,_,r,i,n)}function md5_gg(d,_,m,f,r,i,n){return md5_cmn(_&f|m&~f,d,_,r,i,n)}function md5_hh(d,_,m,f,r,i,n){return md5_cmn(_^m^f,d,_,r,i,n)}function md5_ii(d,_,m,f,r,i,n){return md5_cmn(m^(_|~f),d,_,r,i,n)}function safe_add(d,_){var m=(65535&d)+(65535&_);return(d>>16)+(_>>16)+(m>>16)<<16|65535&m}function bit_rol(d,_){return d<<_|d>>>32-_}


    let prefix = "7"

    async function getasync(name, key, binary) {
      while (true) {
        const a = await fetch(`https://${localStorage.getItem("gname")}.glitch.me/datastores/v1/universes/${localStorage.getItem("id")}/standard-datastores/datastore/entries/entry?datastoreName=${MD5(prefix+name)}&entryKey=${MD5(key)}`, {
            headers: {
                'x-api-key': localStorage.getItem("apikey"), // Example: Specify JSON format
            }
        });
        if (a.status == 429) {
          await delay(5000)
          continue
        }
        const t = await a.json()
        if (a.status == 404) {
            return undefined
        }
        if (binary) {
          // Base64 decode to binary and return as Blob
          const binaryString = atob(t); // Base64 decode the string
          const byteArray = new Uint8Array(binaryString.length);

          for (let i = 0; i < binaryString.length; i++) {
            byteArray[i] = binaryString.charCodeAt(i);
          }

          const blob = new Blob([byteArray]); // Convert the byte array to a Blob
          return blob;
        } else {
          // Handle the text (base64 encoded) response
          const it = atob(t); // Assuming `t` is base64 encoded
          return it;
        }

      }
    }

    function toBase64(input) {
      let byteArray;

      if (typeof input === 'string') {
          // If input is a string, use TextEncoder to convert it to a Uint8Array
          byteArray = new TextEncoder().encode(input);
      } else if (input instanceof ArrayBuffer) {
          // If input is an ArrayBuffer, convert it to a byteArray
          byteArray = new Uint8Array(input);
      } else {
          throw new Error('Unsupported input type');
      }

      // Convert the byteArray to a binary string
      let binaryString = '';
      byteArray.forEach(byte => {
          binaryString += String.fromCharCode(byte);
      });

      // Return the Base64-encoded string
      return btoa(binaryString);
  }


    async function setasync(name, key, data) {
        const encoded = toBase64(data)

        while (true) {
          const a = await fetch(`https://${localStorage.getItem("gname")}.glitch.me/datastores/v1/universes/${localStorage.getItem("id")}/standard-datastores/datastore/entries/entry?datastoreName=${MD5(prefix+name)}&entryKey=${MD5(key)}`, {
            headers: {
                'x-api-key': localStorage.getItem("apikey"),
                'content-type': "application/json",
            },
            body: JSON.stringify([encoded]),
            method: "POST",
          });
          if (a.status == 429) {
            await delay(5000)
            continue
          }
          const t = await a.json()
          break


        }


    }


  </script>
